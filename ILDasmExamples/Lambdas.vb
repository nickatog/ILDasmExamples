Public Module Lambdas
    Public Sub Main()
        ' Using lambdas results in some compilation magic to make them act like delegates
        ' In most cases, the body of the method will get defined statically inside a separate class generated by the compiler
        ' Then, a delegate object will be instantiated with the address of that method
        GimmeADelegate(
            Sub()
                Console.WriteLine("Inside the lambda!")
            End Sub)

        ' If the lambda uses any variables defined outside its own body, though, it becomes a closure
        ' In order to represent the environment enclosed by the lambda, a new object will be instantiated with values set to the context
        ' The lambda itself becomes a member method on the object, which can then access the variables in its scope
        Dim text As String = "Inside the closure!"

        GimmeADelegate(
            Sub()
                Console.WriteLine(text)
            End Sub)

        ' This closure behavior can lead to some tricky behavior when used within loops and the iteration variable is in the context:
        Dim results As IEnumerable(Of Integer) = Enumerable.Empty(Of Integer)()

        Dim numbers As New List(Of Integer)() From {1, 2, 3}
        For index As Integer = 1 To 4
            ' IntelliSense will give us a warning now letting us know that we might get unexpected results due to this
            results =
                results _
                .Concat(numbers.Where(Function(__number) __number >= index))
        Next

        ' Mysteriously prints 0...
        Console.WriteLine(results.Count())
    End Sub

    Public Sub GimmeADelegate(
        ByVal callback As Action)

        callback()
    End Sub
End Module
