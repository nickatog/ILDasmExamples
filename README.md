# ILDasmExamples
Intro to .NET CIL and ILDasm Examples

## Intro to CIL

### What happens when I compile my .NET code?
- .NET code is run by a virtual execution system known as the Common Language Runtime (CLR) on Windows machines.
- The CLR itself doesn't know anything about C# or VB.NET; it uses Common Intermediate Language (CIL) instructions instead.
- CIL is similar to assembly, but still at a much higher level than machine code.
- Compiled .NET code results in CIL instructions, which is why different languages like C# and VB.NET can be used together.

### Why do I need to know about CIL?
- CIL represents what the CLR will actually perform, which may sometimes be different than what you expected your code to do.
- When it comes to optimization, it helps to know what the high-level code is being converted to in CIL.
- Some programming constructs do not work similarly across languages; examining the CIL can confirm the behavior.
- Many instances of syntactic sugar in programming languages are really just cases of compiler magic: things like properties, lambda functions, and async methods look much different after compilation.

## ILDasm

### What is it, and how do I get it?
- The IL Disassembler (ILDasm) allows you to inspect the CIL and metadata contained within a .NET assembly.
- It's installed by default with Visual Studio: depending on your version, somewhere in %ProgramFiles%/Microsoft SDKs/Windows/.

### Symbols
ILDasm will allow you to inspect namespaces, classes, interfaces, value classes (structures), methods, and more. A full reference can be found at: https://msdn.microsoft.com/en-us/library/aa309387(v=vs.71).aspx.

### Opcodes
CIL consists of a large number of base instructions and object model instructions. Wikipedia has a good reference at: https://en.wikipedia.org/wiki/List_of_CIL_instructions.

## Examples

### Gotchas
- Boxing
  - Boxing happens whenever the CLR needs a reference to an object but only has a value instance to work with.
  - Sometimes hard to see in code, but easy to find in CIL since there's an object model instruction for it.
  - Addition of generic collections (among others) in .NET 2.0 helped to reduce the need for boxing across the board.
  - We want to avoid boxing as much as possible, because each boxing operation allocations space from the heap, risking a potential garbage collection.

- Strings
  - The compiler is smart enough to optimize away any concatenations of literal text, so you don't have to sacrifice code readability for performance.
  - Literal string values in the source code are automatically pooled in the CLR (after any optimization concatenations).

- Existence
  - VB.NET supports both an "IsNothing()" method and the keyword operator "Is Nothing".
  - When possible, prefer the keyword usage as it compiles down to simple CIL opcodes instead of a call.
  - Method calls will generally always be heavier than other base instructions due to additional hidden initialization/cleanup code.

### Syntactic sugar
- Enumeration
  - "For Each" loops can be used with any data structure that implements the IEnumerable interface.
  - The loop itself is compiled to a handful of actions that use the methods defined by the interface and branch according to the current value.

- Using
  - "Using" blocks can be used with any object that implements the IDisposable interface.
  - During compilation, code within the block will automatically be wrapped in a Try..Finally, and Dispose() is guaranteed to be called.

- LINQ
  - Query syntax only makes sense to the compiler; it's really just an abstraction on top of a set of extension methods.
  - Most of the LINQ methods are extension methods for IEnumerable/IQueryable and take delegates as parameters.

- Lambdas
  - Using lambda functions results in some compilation magic to make them act like delegates, something the CLR knows how to use.
  - The body of the lambda will typically get defined statically inside a separate class generated by the compiler.
  - Delegate objects can then be instantiated with the address of that method.
  - Closures are a bit different: in order to represent the environment enclosed by the lambda, a new object will be instantiated with values set to the context.

- Async
  - The compilation for async methods is similar to lambda functions, but a bit more complicated to act like a state machine.
  - The class defines a MoveNext() method that is used by the task scheduler to progress through the body of the original pre-compiled method.
